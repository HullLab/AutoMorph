#!/usr/bin/env python

import ConfigParser
import sys
import os
import pwd
import glob
import subprocess
import shutil
import tarfile

import zerene


def focus(directories, software, ID):

    if debug:
        print 'Backing up unprocessed image to originals directory...'
        orig_dir = os.path.join(directories['input'], 'originals')
        if os.path.exists(orig_dir):
            sys.exit("Error: originals directory already exists, please remove before proceeding.")

        focus_dir = os.path.join(directories['input'], 'focused')
        if os.path.exists(focus_dir):
            sys.exit("Error: this directory has already been focused, please clean out before proceeding.")

        shutil.copytree(directories['input'], orig_dir)

    directories['objects'] = [os.path.realpath(x) for x in glob.glob(os.path.join(directories['input'], '*_obj*'))]

    # STRIPPING LABELS
    print 'Stripping labels from', len(directories['objects']), 'images..'
    directories['stripped'] = os.path.join(directories['input'], 'stripped')
    if not os.path.exists(directories['stripped']):
        os.makedirs(directories['stripped'])

    print 'Stripping labels from', len(directories['objects']), 'images..'
    strip_labels(directories)
    print 'Stripping labels complete.'

    # RUNNING EXTERNAL SOFTWARE

    if software['name'] == "zerene":

        # Initialize the batch XML file
        zerene.write_batchfile(directories)

        # Run the XML file
        zerene_command = zerene.construct_command(software)
        zerene_command += ' %s > %s' % (os.path.join(directories['input'], 'zsbatch.xml'),
                                        os.path.join(directories['input'], 'zerene.log'))
        print 'Running Zerene Stacker: ', zerene_command

#        subprocess.call(zerene_command, shell=True)

        first_object = os.path.realpath(os.path.join(directories['stripped'],
                                                     os.path.basename(directories["objects"][0]),
                                                     'ZS.tif'))
        last_object = os.path.realpath(os.path.join(directories['stripped'],
                                                    os.path.basename(directories["objects"][-1],
                                                    'ZS.tif')))

        if not os.path.exists(first_object):
            sys.exit("Error: Zerene didn't create files. Perhaps something went wrong? Exiting...")
        elif not os.path.exists(last_object):
            sys.exit("Error: Zerene didn't finish creating files. Perhaps something went wrong? Exiting...")
        else:
            print 'Zerene Stacker finished!'

    # ADD BACK LABELS
    print 'Re-labeling images ...'

    if not os.path.exists(directories['final_focused']):
        os.makedirs(directories['final_focused'])

    if not os.path.exists(directories['unlabeled_focused']):
        os.makedirs(directories['unlabeled_focused'])

    if not os.path.exists(directories['zstack']):
        os.makedirs(directories['zstack'])

    add_labels(directories)

    # ARCHIVE
    print 'Archiving focused images ... '

    for object_dir in directories['objects']:
        shutil.move(object_dir, directories['zstack'])

    # Final Images
    archive(ID+'-focused.tar', directories['final_focused'], directories)

    # Z-stacks (Original Segmented Images?)
    archive(ID+'-z.stacks.tar', directories['zstack'], directories)


def archive(tar_filename, dir_to_tar, directories):

    tar_filename = os.path.join(os.path.dirname(directories['input']), tar_filename)
    tar = tarfile.open(tar_filename, 'w:gz')
    tar.add(dir_to_tar)
    tar.close()


def strip_labels(directories):

    for object in directories['objects']:
        currentdir = os.path.join(directories['stripped'], os.path.basename(object))
        if not os.path.exists(currentdir):
            os.makedirs(currentdir)

        print 'Cropping ', os.path.basename(object)
        files = [os.path.realpath(x) for x in glob.glob(os.path.join(object, '*plane*tif'))]
        for infile in files:
            # It'd be nice to use the ImageMagick API here,.. but it doesn't
            # yet work, so we're using a system call instead:
            fname = os.path.splitext(os.path.basename(infile))[0]+".jpg"
            outfile = os.path.join(directories['input'], 'stripped', os.path.basename(object), fname)
            convert_command = 'convert ' + infile + ' -crop +0-160 +repage ' + outfile
            subprocess.call(convert_command, shell=True)


def add_labels(directories):

    for object_dir in directories['objects']:
        print 'Adding labels to ', object_dir

        object_name = os.path.basename(object_dir)
        top_file = os.path.realpath(sorted(glob.glob(os.path.join(object_dir, '*plane*tif')))[-1])

        # Grab the label:
        label_file = os.path.realpath(os.path.join(object_dir, 'label.tif'))
        #   convert ${HIGHEST} -gravity South -crop 0x160+0+0 ${directories['input']}/stripped/${label_dir}/label.tif
        # convert_command = 'convert ' + top_file + ' -gravity South -crop 0x160+0+0 ' + label_file
        convert_command = "convert %s -gravity South -crop 0x160+0+0 %s" % (top_file, label_file)
        subprocess.call(convert_command, shell=True)

        convert_command = """convert {0} -fill white -stroke white -draw "path 'M 0,143 l 99999,0 l 0,20 l -99999,0 '" {1} """.format(label_file, label_file)
        subprocess.call(convert_command, shell=True)

        # Add label
        edf_file = os.path.realpath(os.path.join(directories['final_focused'], object_name+"_edf.jpg"))
        zs_file = os.path.realpath(os.path.join(directories['stripped'], object_name, 'ZS.tif'))

        convert_command = "convert -append %s %s %s" % (zs_file, label_file, edf_file)
        subprocess.call(convert_command, shell=True)

        unlabeled_file = os.path.realpath(os.path.join(directories['unlabeled_focused'], object_name+".tif"))
        convert_command = "convert %s %s" % (zs_file, unlabeled_file)
        subprocess.call(convert_command, shell=True)
        # shutil.copyfile(zs_file, unlabeled_file)


def load_settings():

    filename = os.path.join(os.path.dirname(os.path.realpath(__file__)), 'focus.cfg')

    parser = ConfigParser.SafeConfigParser(allow_no_value=True)
    parser.optionxform = str  # preserve case

    parser.read(filename)

    software = {}
    # set required variable
    software['name'] = parser.get('focus', 'software')

    if software['name'] not in ['zerene']:
        sys.exit('Unrecongized software. Available software: zerene')

    for setting in parser.options(software['name']):
        software[setting] = str(parser.get(software['name'], setting))

    return software


def clean(directories):

    if not os.path.exists(directories['zstack_tar']):
        sys.exit('Error: tar of zstack files not present! Exiting...')

    if os.path.exists(directories['stripped']):
        shutil.rmtree(directories['stripped'])

    if os.path.exists(directories['zstack']):
        shutil.rmtree(directories['zstack'])


def reset(directories, ID):

    if os.path.exists(directories['final_focused']):
        shutil.rmtree(directories['final_focused'])
    if os.path.exists(directories['unlabeled_focused']):
        shutil.rmtree(directories['unlabeled_focused'])
    if os.path.exists(directories['stripped']):
        shutil.rmtree(directories['stripped'])

    if os.path.exists(directories['focus_tar']):
        os.remove(directories['focus_tar'])
    if os.path.exists(directories['zstack_tar']):
        os.remove(directories['zstack_tar'])

    # copy back originals if they have been moved
    if os.path.exists(directories['zstack']):
        if os.listdir(directories['zstack']) != []:
            for directory in os.listdir(directories['zstack']):
                shutil.move(directory, directories['input'])
        os.rmdir(directories['zstack'])


if __name__ == "__main__":

    mode = 'focus'
    if len(sys.argv) != 2:
        if len(sys.argv) == 3:
            mode = sys.argv[2]

        else:
            print 'Use: focus <directory name> <mode>'
            print 'mode is optional, can be set to:'
            print 'leave out to run focus normally'
            print 'reset: will revert the directory back to the pre-focused state'
            print 'clean: to remove intermediate files created by focus'
            sys.exit(0)

    # If that option isn't a directory name, quite:
    if not os.path.isdir(sys.argv[1]):
        print 'Argument to focus must be a directory name - quitting.'
        sys.exit(0)

    # Assign our directory variables:
    input_dir = os.path.realpath(sys.argv[1])

    # Assign our ID variable:
    ID = os.path.basename(os.path.normpath(input_dir)[0:9]
    print 'ID = ', ID

    directories = {'input': input_dir,
                   'final_focused':  os.path.join(input_dir, 'focused'),
                   'unlabeled_focused': os.path.join(input_dir, 'focused_unlabeled'),
                   'zstack': os.path.join(input_dir, 'z.stacks'),
                   'focus_tar': os.path.join(input_dir, ID+'-focused.tar'),
                   'zstack_tar': os.path.join(input_dir, ID+'-z.stacks.tar)
                    }

    software = load_settings()

    if mode == "focus":
        print 'Running Focus on ', directories['input']
        focus(directories, software, ID)

    elif mode == "reset":
        reset(directories, ID)

    elif mode == "clean":
        sys.exit("Error: clean mode not implemented yet.")
        clean(directories)

    else:
        sys.exit("Error: Unrecongized mode. Accepted modes are reset and clean.")





