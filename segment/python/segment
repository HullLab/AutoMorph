#!/usr/bin/env python

import settings
import images
import process

import sys
import os


# Segment uses the bounding box identified by the sharpest image in a
# set of stacks to chop just the edf into individual images

# Started on 3/21/2014 by Yusu Liu
# code uses base code of PM Hull (20-Oct-13)with updates by B. Dobbins, PMH, and Y. Liu
# converted to python by K. Nelson (2015-Sept)


def segment(settings_file):

    version = '2015-8-31'

    print "Loading settings from %s..." % settings_file
    runs = settings.parse(settings_file)

    for i, run in enumerate(runs):

        print('Segment - running configuration %d of %d from %s'
              % (i+1, len(runs), settings_file))

        # Get list of images in directory
        target_image_list = images.list_files(run['directory'], run['input_ext'])
        top_image_filename = target_image_list[-1]

        # Set up additonal run parameters

        # Get the microns per pixel for this image: (new, and ugly, modification - Oct. 2014)
        if not (run['pixel_size_x'] and run['pixel_size_y']):
            print 'No pixel size set in settings file, attempting to read microns per pixel from xml file...'
            run['pixel_size_x'], run['pixel_size_y'] = images.microns_per_pixel_xml(top_image_filename)

        run['image_file_label'] = 'th=%05.4f_size=%04.0fu-%04.0fu' % (run['threshold'],
                                                                      run['minimumSize'],
                                                                      run['maximumSize'])

        run['image_label'] = contruct_image_label(run, version)

        if not os.path.exists(run['full_output']):
            os.makedirs(run['full_output'])

        # Load and resize top-level image
        top_image = images.load(top_image_filename, run)

        # Identify all objects based on threshold and size values
        print 'INFO: Finding objects'
        objects = images.find_objects(top_image, run)

        images.save_overview_image(top_image, objects, top_image_filename, run)

        # Leanne said this no long really used, so I've commented it out for later removal
        # if run['mode'] == 'sample':
        #   process.sample(top_image, objects, top_image_filename, run)

        if run['mode'] == 'final':

            print('Saving Settings into %s' % run['full_output'])
            settings.save(run.copy())
            # Loop over the planes we're interested in, load an image, then process it
            for plane_num, plane_image in enumerate(target_image_list[:-1]):
                process.final(plane_image, objects, run, plane_num)


def contruct_image_label(run, version):

    catalog_number = 'None'
    if run['catalog_prefix']:
        if 'IP' in run['unique_id']:  # Special fix for Yale
            catalog_number = run['catalog_prefix']+' '+run['unique_id'].split('.')[1]
        else:
            catalog_number = run['catalog_prefix']+' '+run['unique_id']

    text = []
    text.append('%4.2f %s per pixel | Age and Source:  %s from %s'
                % (run['units_per_pixel'], run['unit'], run['age'], run['source']))
    this_line = 'Processed at '+run['location']

    if run['author']:
        this_line += ' by '+run['author']
    this_line += ' (Catalog Number: %s)' % catalog_number

    text.append(this_line)
    text.append('CODE VERSION: %s, PROCESSED ON: %s' % (version, run['timestamp']))
    text.append('Threshold of %4.2f and size filter of %d - %d %s'
                % (run['threshold'], run['minimumSize'], run['maximumSize'], run['unit']))
    text.append('Directory: %s' % run['subdirectory'])

    return text

if __name__ == "__main__":

    if len(sys.argv) == 2:
        segment(sys.argv[1])

    else:
        print 'Usage: segment <settings_file>'
        sys.exit('Error: incorrect usage')
